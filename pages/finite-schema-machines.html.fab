
âœ³(ns site.fabricate.docs.fsm
                 (:require [site.fabricate.prototype.page :refer :all]
                           [site.fabricate.prototype.read :as read]
                           [couplet.core :as cp]
                           [garden.core :as garden]
                           [garden.stylesheet :refer [at-import]]))ðŸ”š

âœ³ (def metadata
  {:title "Organizing computation with Finite Schema Machines"

:page-style
   (garden/css
    (list
     (at-import "https://fonts.googleapis.com/css2?family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=Inter:wght@900&display=swap")
     [:body {:background-color "#EEEDED"}]
     [:article {:max-width "40em"
                :font-size "22px"
                :line-height "1.35em"
                :font-family "'Inria Sans', sans-serif"
                :border-left-color "#5B2D0D"
                :border-left-style "solid"
                :border-left-width "2em"
                }
      [:section {:padding-left "1.4em"}]
      [:h1 :h2 :h3 :h4 {:font-family "Inter"}]
      [:h1 {:font-size "2.5rem"
            :line-height "1.35em"}]
      [:h2 {:font-size "1.7rem"}]
      [:h3 {:font-size "1.5rem"}]
      [:h4 {:font-size "1.3rem"}]
      [:pre {:white-space "pre-wrap"}]
      ]

     )
    )}) ðŸ”š

âœ³= [:header [:h1 (:title metadata)]
   [:h4 "An extensible method of laying out functions executed by a program."]] ðŸ”š

Let's take a tour through Fabricate's âœ³= [:code "fsm"] ðŸ”š namespace. The implementation is extremely simple right now, consisting of two functions:


âœ³= [:code (read/include-def 'advance "./src/site/fabricate/prototype/fsm.clj")] ðŸ”š


âœ³= [:code (read/include-def 'complete "./src/site/fabricate/prototype/fsm.clj")] ðŸ”š

What do these do? They take a given piece of arbitrary Clojure data, move it through a succession of states. This sequence is defined by a map mapping from  âœ³= [:code "malli"] ðŸ”š schemas to functions. If a piece of data matches one of the states in the keys, it is transformed by calling the corresponding function. If it doesn't, it is returned as-is. There's nothing more to it than that.

The challenge lies in precisely describing the succession of states required by Fabricate.
