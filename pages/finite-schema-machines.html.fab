
âœ³(ns site.fabricate.docs.fsm
                 (:require [site.fabricate.prototype.page :refer :all]
[site.fabricate.prototype.read :as read]
[couplet.core :as cp]
[garden.core :as garden]
))ðŸ”š

âœ³ (def metadata
  {:title "Organizing computation with Finite Schema Machines"

  :page-style (garden/css {:max-width "60em"})}) ðŸ”š

âœ³= [:header [:h1 (:title metadata)]
   [:h4 "An extensible method of laying out functions executed by a program."]] ðŸ”š

Let's take a tour through Fabricate's âœ³= [:code "fsm"] ðŸ”š namespace. The implementation is extremely simple right now, consisting of two functions:


âœ³= [:code (read/include-def 'advance "./src/site/fabricate/prototype/fsm.clj")] ðŸ”š


âœ³= [:code (read/include-def 'complete "./src/site/fabricate/prototype/fsm.clj")] ðŸ”š

What do these do? They take a given piece of arbitrary Clojure data, move it through a succession of states. This sequence is defined by a map mapping from  âœ³= [:code "malli"] ðŸ”š schemas to functions. If a piece of data matches one of the states in the keys, it is transformed by calling the corresponding function. If it doesn't, it is returned as-is. There's nothing more to it than that.

The challenge lies in precisely describing the succession of states required by Fabricate.
