âœ³ (ns site.fabricate.docs.reference.namespaces.api
  (:require [site.fabricate.api :as api]
  [cybermonday.core :as md]
  [site.fabricate.adorn :refer [clj->hiccup]]
  [site.fabricate.dev.build.utils :as utils]
)
  ) ğŸ”š
âœ³(def doc-ns (find-ns 'site.fabricate.api)) ğŸ”š
âœ³(def metadata {:title "Fabricate main API"
               ;; new API, new style
               :page-style (slurp "docs/css/fabricate.css")}) ğŸ”š
               

âœ³= [:div {:class "main-track"}
  [:h1 {:class "contrast-card"} [:span {:class "main-ns"} "site.fabricate.api"] [:br] [:span {:class "ns-annotation"} "Namespace"]]
  (:doc (meta doc-ns))] ğŸ”š

Fabricate's API is meant to be used in a specific order.  This document explains each core aspect step-by-step.
âœ³= [:div {:class "contrast-card"}
[:h2 {:class "primary-fn"} "plan!"]
[:code {:class "primary-fn-fqn"} "site.fabricate.api/" [:strong "plan!"]]
[:div {:class "anti-contrast"}
 [:dl {:class "fn-description"}
  [:dt "Function"] 
  [:dd  (md/parse-body 
         (:doc (meta #'site.fabricate.api/plan!)))]
  [:dt "Inputs"] 
  [:dd [:code {:class "language-clojure"} 
        (->> (meta #'site.fabricate.api/plan!)
             :arglists
             (apply concat)
             (map (fn [i] [:li (utils/expr->hiccup i)]))
             (into [:ol]))
        ]]
  [:dt "Output"]
  [:dd "site: a map with two keys: " [:code (clj->hiccup :site.fabricate.api/entries)] " with the list of entries, and " 
   [:code (clj->hiccup :site.fabricate.api/options)] ", containing site-wide options."]]

]
 ] ğŸ”š

The plan step executes a list of setup functions, and then collects the initial list of entries that will be assembled during the build step. Each implementation of the collect multimethod specifies a source location that entries will be collected from - typically a string indicating a file path - and a function that uses that location to produce a list of entries. 

Each source can produce one or more entries. For example, Fabricate, in building its own documentation, specifies a glob pattern string for its templates: âœ³= [:pre [:code {:class "language-clojure"}
(utils/expr->hiccup '(defmethod api/collect "pages/**.fab"
  [src options]
  (mapv (fn path->entry [p]
          ...)
        (fs/glob (System/getProperty "user.dir") src))))
]
] ğŸ”š

âœ³= 
[:div {:class "contrast-card bg-green"}
[:h2 {:class "primary-fn"} "collect"]
[:code {:class "primary-fn-fqn"} "site.fabricate.api/" [:strong "collect"]]
[:div {:class "anti-contrast"}
 [:dl {:class "fn-description"}
  [:dt "Multimethod"] 
  [:dd  (md/parse-body 
         (:doc (meta #'site.fabricate.api/collect)))]
  [:dt "Inputs"] 
  [:dd [:code {:class "language-clojure"} (clj->hiccup (into [] (apply concat (:arglists (meta #'site.fabricate.api/collect)))))]]
  [:dt "Output"]
  [:dd "a list of entries, specified as maps."]

]
 ]]
 ğŸ”š

The entries collected from all of the sources are flattened into a single vector at the end of the plan step.



âœ³= [:div {:class "card ol-brown"}
  [:div {:class "top bg-brown"} 
   #_[:strong {:class "primary-fn"}  "1."]
   [:h2 {:class "primary-fn"} "assemble"]]
[:dl {:class "fn-description"}
 [:dt "Function"] [:dd  (md/parse-body (:doc  (meta #'api/assemble)))]
 [:dt "Inputs"] [:dd [:code {:class "language-clojure"} 
        (->> (meta #'site.fabricate.api/assemble)
             :arglists
             (apply concat)
             (map (fn [i] [:li (utils/expr->hiccup i)]))
             (into [:ol]))
        ]]
 [:dt "Output"] [:dd "A site, specified as a map."]
 ]
] ğŸ”š