âœ³ (ns site.fabricate.docs.reference.namespaces.api
  (:require [site.fabricate.api :as api]
  [cybermonday.core :as md]
  [dev.onionpancakes.chassis.core :as c]
  [site.fabricate.adorn :refer [clj->hiccup]]
  [site.fabricate.dev.build.utils :as utils]
  [rewrite-clj.zip :as z]
  [rewrite-clj.parser :as parser]
  [rewrite-clj.node :as node]
)
  ) ðŸ”š
âœ³(def doc-ns (find-ns 'site.fabricate.api)) ðŸ”š
âœ³(def metadata {:title "Fabricate main API"
               ;; new API, new style
               :page-style (slurp "docs/css/fabricate.css")}) ðŸ”š
               

âœ³= [:div {:class "card"
        :id "top"
        :style {:outline-color "var(--color-blue)"}}
  [:h1 {:style {:grid-column-start "1" :margin-top "0em"
                :background "var(--color-blue)"
                :color "var(--color-sand)"}} [:span {:class "main-ns"} 
"site." [:wbr] "fabricate." [:wbr] "api"
#_"site.fabricate.api"] [:br] [:span {:class "ns-annotation"
                                                                                                           } "Namespace"]]
  [:div {:style {:grid-column "1 / 7"}} (:doc (meta doc-ns))]] ðŸ”š

Fabricate's API is meant to be used in a specific order.  This document explains each core aspect step-by-step.
âœ³= [:div {:class "card ol-brown"
        :id "plan!"}
  [:div {:class "top bg-brown "} [:h2 {:class "primary-fn"} "plan!"]
   [:code {:class "primary-fn-fqn"} "site.fabricate.api/" [:strong "plan!"]]]
  
  [:dl {:class "fn-description"
        }
   [:dt "Function"] 
   [:dd  (md/parse-body 
          (:doc (meta #'site.fabricate.api/plan!)))]
   [:dt "Inputs"] 
   [:dd [:code {:class "language-clojure"} 
         (->> (meta #'site.fabricate.api/plan!)
              :arglists
              (apply concat)
              (map (fn [i] [:li (utils/expr->hiccup i)]))
              (into [:ol]))
         ]]
   [:dt "Output"]
   [:dd "site: a map with two keys: " [:code (clj->hiccup :site.fabricate.api/entries)] " with the list of entries, and " 
    [:code (clj->hiccup :site.fabricate.api/options)] ", containing site-wide options."]]


 ] ðŸ”š

The plan step executes a list of setup functions, and then collects the initial list of entries that will be assembled during the build step. Each implementation of the collect multimethod specifies a source location that entries will be collected from - typically a string indicating a file path - and a function that uses that location to produce a list of entries. 

Each source can produce one or more entries. For example, Fabricate, in building its own documentation, specifies a glob pattern string for its templates: âœ³= [:pre [:code {:class "language-clojure"}
(utils/expr->hiccup '(defmethod api/collect "pages/**.fab"
  [src options]
  (mapv (fn path->entry [p]
          ...)
        (fs/glob (System/getProperty "user.dir") src))))]] ðŸ”š

âœ³= 
[:div {:class "card"
       :id "collect"
       :style {:outline-color "var(--color-green)"}}
 [:div {:class "top bg-green" }
  [:h2 {:class "primary-fn"} "collect"]
  [:code {:class "primary-fn-fqn"} "site.fabricate.api/" [:strong "collect"]]]
  
 [:dl {:class "fn-description"}
  [:dt (c/raw "Multi&shy;method") ] 
  [:dd  (md/parse-body 
         (:doc (meta #'site.fabricate.api/collect)))]
  [:dt "Inputs"] 
  [:dd #_[:code {:class "language-clojure"} (clj->hiccup (into [] (apply concat (:arglists (meta #'site.fabricate.api/collect)))))
        ]
   [:ol [:li "A source - any Clojure value"] [:li "An options map"]]
   
]
  [:dt "Output"]
  [:dd "a list of entries, specified as maps."]

  ]
 ]
 ðŸ”š

The entries collected from all of the sources are flattened into a single vector at the end of the plan step and returned with the site.

âœ³= [:div {:class "card ol-brown"
        :id "assemble"}
  [:div {:class "top bg-brown"} 
   #_[:strong {:class "primary-fn"}  "1."]
   [:h2 {:class "primary-fn"} "assemble"]
[:code {:class "primary-fn-fqn"} "site.fabricate.api/" [:strong "assemble"]]]
[:dl {:class "fn-description"}
 [:dt "Function"] [:dd  (md/parse-body (:doc  (meta #'api/assemble)))]
 [:dt "Inputs"] [:dd [:code {:class "language-clojure"} 
        (->> (meta #'site.fabricate.api/assemble)
             :arglists
             (apply concat)
             (map (fn [i] [:li (utils/expr->hiccup i)]))
             (into [:ol]))
        ]]
 [:dt "Output"] [:dd "A site, specified as a map."]
 ]
] ðŸ”š

The assemble step builds structured data for each entry generated by the plan step. Each entry gets passed to the build multimethod.

After this, each function in the sequence of tasks passed as an argument gets called on the resulting site, in order. This lets you do things like assemble additional entries - like a table of contents, index, or site map - from the contents of the entries after they get built.

âœ³=

[:div {:class "card" 
       :id "build"
       :style {:outline-color "var(--color-green)"}}
  [:div {:class "top bg-green"} 
   #_[:strong {:class "primary-fn"}  "1."]
   [:h2 {:class "primary-fn"} "build"]
[:code {:class "primary-fn-fqn"} "site.fabricate.api/" [:strong "build"]]]
[:dl {:class "fn-description"}
 [:dt (c/raw "Multi&shy;method")] [:dd  (md/parse-body (:doc  (meta #'api/build)))]
 [:dt "Inputs"] [:dd #_[:code {:class "language-clojure"} 
        (->> (meta #'site.fabricate.api/build)
             :arglists
             (apply concat)
             (map (fn [i] [:li (utils/expr->hiccup i)]))
             (into [:ol]))]
      [:ol [:li "An entry map"] [:li "An options map"]]]
 [:dt "Output"] [:dd "An entry, specified as a map."]
 ]
]

 ðŸ”š

Build dispatches on two keys for each entry:
âœ³= [:ol {:style {:grid-column "2 / 6"}} [:li [:code {:class "language-clojure keyword"} ":site.fabricate.source/format"]]
[:li [:code {:class "language-clojure keyword"} ":site.fabricate.document/format"]] ] ðŸ”š

Because of this, each implementation of collect should define a format for each entry it produces.



When built, the entry will have a key -  âœ³= [:code {:class "language-clojure keyword"}
":site.fabricate.document/data"] ðŸ”š  - containing the document after its conversion into Clojure data. Fabricate's default build methods return Hiccup from one of Fabricate's 3 built-in sources: Fabricate templates, Clojure source code, and Markdown files.

However, because it dispatches on any keyword, your implementation of build can extend Fabricate to any method of representing structured information in Clojure, or override these defaults.

âœ³= [:div {:class "card ol-brown"
        :id "construct!"}
  [:div {:class "top bg-brown"} 
   #_[:strong {:class "primary-fn"}  "1."]
   [:h2 {:class "primary-fn"} "construct!"]
[:code {:class "primary-fn-fqn"} "site.fabricate.api/" [:strong "construct!"]]]
[:dl {:class "fn-description"}
 [:dt "Function"] [:dd  (md/parse-body (:doc  (meta #'api/construct!)))]
 [:dt "Inputs"] [:dd [:code {:class "language-clojure"} 
        (->> (meta #'api/construct!)
             :arglists
             (apply concat)
             (map (fn [i] [:li (utils/expr->hiccup i)]))
             (into [:ol]))
        ]]
 [:dt "Output"] [:dd "A site, specified as a map."]
 ]
]  ðŸ”š

The construct! function uses the structured content assembled in the previous step to produce output pages for the site.

By default, they are HTML. Any other output format could be generated from the entries by âœ³= [:code {:class "language-clojure keyword"} "produce!"] ðŸ”š 

âœ³= 
[:div {:class "card" 
       :id "produce!"
       :style {:outline-color "var(--color-green)"}}
  [:div {:class "top bg-green"} 
   #_[:strong {:class "primary-fn"}  "1."]
   [:h2 {:class "primary-fn"} "produce!"]
[:code {:class "primary-fn-fqn"} "site.fabricate.api/" [:strong "produce!"]]]
[:dl {:class "fn-description"}
 [:dt (c/raw "Multi&shy;method") ] [:dd  (md/parse-body (:doc  (meta #'api/produce!)))]
 [:dt "Inputs"] [:dd #_[:code {:class "language-clojure"} 
        (->> (meta #'site.fabricate.api/build)
             :arglists
             (apply concat)
             (map (fn [i] [:li (utils/expr->hiccup i)]))
             (into [:ol]))]
      [:ol [:li "An entry map"] [:li "An options map"]]]
 [:dt "Output"] [:dd "An entry, specified as a map."]
 ]
]

 ðŸ”š

The produce! multimethod creates output for the entry passed as an argument. It dispatches on two keys:

âœ³= [:ol {:style {:grid-column "2 / 6"}} [:li [:code {:class "language-clojure keyword"} ":site.fabricate.document/format"]]
[:li [:code {:class "language-clojure keyword"} ":site.fabricate.page/format"]] ] ðŸ”š

The implementation will generate output of the given page format from data of the given document format. By default, this is a HTML file, generated from the Hiccup data built in the assemble step.

The produce! multimethod returns an entry with a key added: âœ³= [:code {:class "language-clojure keyword"} ":site.fabricate.page/location"] ðŸ”š. This key indicates the URL or file path of a generated page.
âœ³= [:figure {:style {:grid-column "3 / span 4"
                   :margin 0
                   }} [:img {:src "/media/api-illustration.svg"
                } ]] ðŸ”š
âœ³= [:h2 {:id "in-use"
       :style {:font-size "var(--font-big)"
               :border-bottom "solid var(--color-yellow) var(--grid-gap-x)"
               }} "In use"] ðŸ”š

The API provides an elegant combination of extensibility and ease of use. This example is simplified from Fabricate's own page generation code.

âœ³= [:pre [:code {:class "language-clojure"} (utils/expr->hiccup '(require 
[site.fabricate.api :as api]
[site.fabricate.dev.styles :as styles]
[site.fabricate.prototype.time :as time]
[site.fabricate.prototype.read :as read]
[site.fabricate.prototype.read.grammar :as grammar]
[site.fabricate.prototype.hiccup :as hiccup]
[dev.onionpancakes.chassis.core :as c]
            ))]] ðŸ”š

âœ³ (def build-ns-zip (z/of-node (parser/parse-file-all "dev/site/fabricate/dev/build.clj"))) ðŸ”š
âœ³= [:h3 {:style {:font-size "var(--font-medium)"}} "Setting up with " [:code {:class "language-clojure symbol"} "defmethod"]] ðŸ”š

Before running the API's 3 main functions, the build process defines methods for each of these multimethods.

âœ³= [:h4 {:style {:font-size "var(--font-medium)"}} "1. " [:code {:class "language-clojure symbol"} "api/collect"]] ðŸ”š

This implementation generates entries from each Fabricate template.
âœ³= [:pre {:id "collect-template-example"}
   [:code {:class "language-clojure"}
    (-> build-ns-zip
            (z/find-next (fn [zloc]
                           (let [n  (z/node zloc)
                                 cforms (node/child-sexprs n)]
                             (and cforms
                                  (= 'defmethod (first cforms))
                                  (= 'api/collect (second cforms))
                                  (= "pages/**.fab" )))))
            z/sexpr
            utils/expr->hiccup)

    ]
  
  ] ðŸ”š


To dynamically create the contents of the README from a template, Fabricate also defines a single-file source for it:
âœ³= [:pre {:id "collect-readme-example"}
  [:code {:class "language-clojure"}
   (-> build-ns-zip
            (z/find-next (fn [zloc]
                           (let [n  (z/node zloc)
                                 cforms (node/child-sexprs n)]
                             (and cforms
                                  (= 'defmethod (first cforms))
                                  (= 'api/collect (second cforms))
                                  (= "README.md.fab")))))
            z/sexpr
            utils/expr->hiccup)]] ðŸ”š


âœ³= [:h4 {:style {:font-size "var(--font-medium)"}} "2. " [:code {:class "language-clojure symbol"} "api/build"]] ðŸ”š
This implementation of the build multimethod evaluates Fabricate's templates and produces Hiccup from the results.

âœ³= [:pre [:code {:class "language-clojure"} 
        (-> build-ns-zip
            (z/find-next (fn [zloc]
                           (let [n  (z/node zloc)
                                 cforms (node/child-sexprs n)]
                             (and cforms
                                  (= 'defmethod (first cforms))
                                  (= 'api/build (second cforms))
                                  (= [:site.fabricate.read/v0 :hiccup])))))
            z/sexpr
            utils/expr->hiccup)]] ðŸ”š

âœ³= [:h4 {:style {:font-size "var(--font-medium)"}} "3. " [:code {:class "language-clojure symbol"} "api/produce!"]] ðŸ”š

This implementation of the produce! generates HTML from Hiccup elements. 


âœ³= [:pre [:code {:class "language-clojure"} 
        (-> build-ns-zip
            (z/find-next (fn [zloc]
                           (let [n  (z/node zloc)
                                 cforms (node/child-sexprs n)]
                             (and cforms
                                  (= 'defmethod (first cforms))
                                  (= 'api/produce! (second cforms))
                                  (= [:hiccup :html])))))
            z/sexpr
            utils/expr->hiccup)]] ðŸ”š

âœ³= [:h3 {:style {:font-size "var(--font-medium)"}} "Evaluating using the main API functions" ] ðŸ”š
Fabricate defines a few setup functions:
âœ³= [:pre [:code {:class "language-clojure"} 
        (-> build-ns-zip
            (z/find-next (fn [zloc]
                           (let [n  (z/node zloc)
                                 cforms (node/child-sexprs n)]
                             (and cforms
                                  (= 'def (first cforms))
                                  (= 'setup-tasks (second cforms))
                                  ))))
            z/sexpr
            utils/expr->hiccup)]] ðŸ”š
And some options:
âœ³= [:pre [:code {:class "language-clojure"} 
        (-> build-ns-zip
            (z/find-next (fn [zloc]
                           (let [n  (z/node zloc)
                                 cforms (node/child-sexprs n)]
                             (and cforms
                                  (= 'def (first cforms))
                                  (= 'options (second cforms))
                                  ))))
            z/sexpr
            utils/expr->hiccup)]] ðŸ”š

With all of that defined, this is all that Fabricate needs to do to generate its own documentation:
âœ³= [:pre [:code {:class "language-clojure"}
        (utils/expr->hiccup 
         '(->> {:site.fabricate.api/options options}
                    (api/plan! setup-tasks)
                    (api/assemble [])
                    (api/construct! [])))]] ðŸ”š