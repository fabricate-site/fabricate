âœ³(ns site.fabricate.docs.background.templates
(:require
[clojure.string :as str]
[site.fabricate.prototype.read.grammar :as grammar]
[garden.core  :as garden]
[site.fabricate.styles :as styles]
            [site.fabricate.prototype.page :as page])) ðŸ”š


âœ³(def metadata {:title "An Informal Guide to Fabricate Page Templates" :page-style (garden/css styles/docs)})ðŸ”š


âœ³=[:h1 (:title metadata)]ðŸ”š

âœ³=[:h2 "An informal guide"]ðŸ”š

This page has an informal explanation of the parts that make up a Fabricate page. They are each explained individually, and then assembled into an example document so you can see the inputs and the outputs together.

âœ³=[:h3 "Basic Expressions"]ðŸ”š

An expression starts and ends with the asterisk and END emojis: âœ³=(into [:span] grammar/delimiters)ðŸ”š. You can then use some optional control characters to change how that expression will be used by Fabricate. All expressions in those emoji will be evaluated after Fabricate reads the page template and parses it.

One thing that makes Fabricate different is the fact that templates can appear anywhere in the text. So if you wanted to write a sentence generated by a Clojure program in the middle of an ordinary paragraph, you can do that. If you want to define a variable naming all the sections and write a sentence like "this page has âœ³=3ðŸ”š sections," you can do that. Fabricate, by default, uses inline expressions instead of Markdown.

âœ³=[:h4 (first grammar/delimiters) " - " "Run expressions"]ðŸ”š

If you don't specify any additional characters, Fabricate evaluates the expression without putting the result in the page.

Useful for: namespace declarations, variable definitions, and other side effects - anything where you don't need to see the result of what you run.
âœ³(def run-exprs
   '[(ns my-demo-ns
       (:require [site.fabricate.prototype.page :as page]))
     (def metadata {:title "My page"})])ðŸ”š
âœ³=(list [:h5 "Examples"]
      (apply conj [:div {:style (garden/style {:font-size "0.75em"})}]
            (for [expr run-exprs]
              [:pre [:code (page/simple-expr expr {:ctrl-char ""})]])))ðŸ”š

âœ³=[:h4 (first grammar/delimiters) "= - " "Yield expressions"]ðŸ”š

âœ³(def yield-exprs
  (list [:code {:class "language-clojure"} "(map inc (range 40 29 -1))"]
        [:figure
         [:blockquote "People are alive -- they behave and respond. Creations within the computer can also live, behave, and respond... if they are allowed to."]
         [:figcaption "Bret Victor, "
          [:a {:href "https://vimeo.com/64895205"}
           [:em "Stop Drawing Dead Fish"]]]]
        [:img {:src "https://live.staticflickr.com/3770/11073365765_6dd38cce29_z.jpg"}])) ðŸ”š

If you add the "=" character after the asterisk - âœ³=[:span (first grammar/delimiters) "="]ðŸ”š, the expression's results get added into the page. Hiccup expressions, like âœ³=[:code "[:code \"example inline code\"]"]ðŸ”š are included in the document tree and will be transformed into HTML all at once after the document is evaluated.

Useful for: anything you'd use HTML for.

âœ³= (list [:h5 "Examples"]
       [:div
        (apply list
               (for [expr yield-exprs]
                 [:div {:style (garden/style {:display "flex" :flex-flow "row wrap" :justify-content "space-between" :column-gap "1em"})}
                  [:div {:style (garden/style {:flex "1 1 30ch" :font-size "0.75em"})} [:pre [:code (page/simple-expr expr {:ctrl-char "="})]]]
                  [:div {:style (garden/style {:flex "1 1 30ch"})} expr]]))])
        ðŸ”š

âœ³=[:h4 (first grammar/delimiters) "+"  "Insert expressions"]ðŸ”š

Use this for when you want to evaluate some code and insert the expression into the result, but not its output.

Useful for: when you want to demonstrate some code that contributes to the page but its output isn't important. You could show the code used to define a variable, but use the the contents of that variable later on in the page. It's also useful for instructive function definitions, where the return value of a function definition is just a var.

âœ³(def insert-exprs
'[(defn de-jong
    "Returns a Peter de Jong attractor function. Use with iterate."
    [^Double a ^Double b ^Double c ^Double d]
    (fn [[^Double x ^Double y]]
      [(- (Math/sin (* a y)) (Math/cos (* b x)))
       (- (Math/sin (* c x)) (Math/cos (* d y)))]))
  (defn clifford
    "Returns a Clifford attractor function. Use with iterate."
    [^Double a ^Double b ^Double c ^Double d]
    (fn [[^Double x ^Double y]]
      [(- (Math/sin (* a y)) (* c (Math/cos (* a x))))
       (- (Math/sin (* b x)) (* d (Math/cos (* b y))))]))
  (def de-jong-example
    (de-jong 1.517 -2.001 3.45 2.07))
  (def clifford-example (clifford 1.24 1.14 1.23 1.89))])ðŸ”š

âœ³=(list [:h5 "Examples"]
(apply conj [:div {:style (garden/style {:font-size "0.75em"})}]
       (for [expr insert-exprs]
         [:div {:style (garden/style {:display "flex" :flex-flow "row wrap" :justify-content "space-between" :column-gap "1em"})}

          [:pre
           {:style (garden/style {:flex "1 1 30ch"})}
           [:code (page/simple-expr expr {:ctrl-char "+"})]]
          [:pre
           {:style (garden/style {:flex "1 1 30ch"})}
           [:code {:class "language-clojure"} (str expr)]]
          ])))ðŸ”š

âœ³=[:h4 (first grammar/delimiters) "+=" "Composing control characters"]ðŸ”š

You can use both the "+" and "=" characters together to display a form along with its output.


Useful for: showing off your art alongside the code that produced it.

âœ³(doseq [expr insert-exprs] (eval expr))ðŸ”š

âœ³(def insert-display-exprs
  '[(let [w 300 h 400]
      (into [:svg {:id "de-jong-fractal" :width w :height h}]
            (map (fn [[^Double x ^Double y]]
                   [:circle {:cx (* w (+ 0.5 (/ x 4.0)))
                             :cy (* h (+ 0.5 (/ y 5.0)))
                             :style {:opacity 0.3 :fill "#606456"}
                             :r 1.0}])
                 (take 15000
                       (iterate
                        de-jong-example
                        [1.4 3.9])))))
(let [w 300 h 400]
      (into [:svg {:id "clifford-fractal" :width w :height h}]
            (map (fn [[^Double x ^Double y]]
                   [:circle {:cx (* w (+ 0.5 (/ x 4.0)))
                             :cy (* h (+ 0.5 (/ y 5.0)))
                             :style {:opacity 0.3 :fill "#606456"}
                             :r 1.0}])
                 (take 15000
                       (iterate
                        clifford-example
                        [1.4 3.9])))))
    ])ðŸ”š



âœ³=(list [:h5 "Examples"]
(apply conj [:div]
       (for [expr insert-display-exprs]
         [:div {:style (garden/style {:display "flex" :flex-flow "row wrap" :justify-content "space-between" :column-gap "1em"})}

          [:pre
           {:style (garden/style {:flex "1 1 30ch" :font-size "0.75em"})}
           [:code (page/simple-expr expr {:ctrl-char "+="})]]
          [:div
           {:style (garden/style {:flex "1 1 30ch"})}
           (eval expr)]
          ])))ðŸ”š

âœ³=[:h4 "Interlude: (code) documentation as data"]ðŸ”š

Not only do these examples illustrate how Fabricate's control characters work, they also show how you can build up components of a page by defining them as variables in Clojure and then using them to produce page elements. I was able to use Flexbox attributes to tailor the layout to my examples without tying the whole page to a single way of displaying things. The example expressions above were defined not as ossified strings in a fenced code block, but as quoted Clojure expressions, some of which were evaluated to produce this page. If they encountered an error on evaluation, an error would have surfaced in the page as I was drafting it. Can you be assured of that when putting example code in Markdown documents?

âœ³=[:h3 "Extended form expressions"]ðŸ”š

Sometimes it's preferable to group multiple forms together along with paragraphs of plain text into a single section. In order to do this without embedding many paragraphs in a single large Fabricate expression, Fabricate also supports extended forms. They allow you to mark the start and end points of an element in a document and continue working within that element normally using Fabricate's mix of plain text and expressions.

âœ³=[:h2 "An example document"]ðŸ”š

âœ³(def example-doc
[{:input ""
:output ""
:description "A namespace declaration for a Fabricate page"}]

)ðŸ”š

âœ³=[:h2 "A longer example: this page"]ðŸ”š

This page itself uses many of the "useful for" tips I mentioned in the first section. You might find the source code of the page instructive, so it is included below:
