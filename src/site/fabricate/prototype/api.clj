(ns site.fabricate.prototype.api
  "Fabricate's public API.

  This contains the core set of operations that Fabricate uses to produce a website from input files."
  (:require [site.fabricate.prototype.read :as read]
            [site.fabricate.prototype.page :as page]
            [site.fabricate.prototype.html :as html]
            [site.fabricate.prototype.time :as time]
            [site.fabricate.prototype.schema :as s]
            [malli.core :as m]
            [malli.util :as mu]
            [hiccup.page]
            [clojure.java.io :as io]
            [clojure.spec.alpha :as spec]
            [babashka.fs :as fs])
  (:import [java.io File]
           [java.net URI]
           [java.time ZonedDateTime Instant ZoneId]))


(def definitions
  [{:doc "A source file used by Fabricate. May be a file, or a URL.",
    :term :site.fabricate.source/location,
    :type [:or :string [:fn fs/exists?]]}
   {:doc
      "The source from which input entries are derived. collect dispatches on ::source",
    :term :site.fabricate.api/source,
    :type :string}
   {:doc
      "A map representing a component of a page before, during, and after the assemble and produce operations. One source may produce multiple entries.",
    :term :site.fabricate.api/entry,
    :type :map}
   {:doc "The file where a page was published.",
    :term :site.fabricate.page/output,
    :type [:fn fs/exists?]}
   {:doc "EDN data structure with the contents of a document.",
    :term :site.fabricate.document/data,
    :type :any}
   {:doc
      "The specification or type of the document data generated by `assemble`. An entry has a single document format.",
    :term :site.fabricate.document/format,
    :type :keyword}
   {:doc
      "The specification or type of the file format from which page data is generated by passing the file's contents to `assemble`. An entry has a single source format.",
    :term :site.fabricate.source/format,
    :type :keyword}
   {:doc
      "The specification or type of the file format that page data is converted to by produce before being written to a file. An entry has one output format.",
    :term :site.fabricate.page/format,
    :type :keyword}
   {:doc "The address at which a page will be accessed after publication.",
    :term :site.fabricate.page/uri,
    :type [:fn uri?]}
   {:doc "The title of a page.",
    :term :site.fabricate.page/title,
    :type :string}
   {:doc "A page's permanent, canonical URL.",
    :term :site.fabricate.page/permalink,
    :type [:fn uri?]}
   {:doc "A brief description of a page's contents.",
    :term :site.fabricate.page/description,
    :type :string}
   {:doc "The author of a given page.",
    :term :site.fabricate.page/author,
    :type :string}
   {:doc "The language a page is written in.",
    :term :site.fabricate.page/language,
    :type :string}
   {:doc "The locale of a page.",
    :term :site.fabricate.page/locale,
    :type :string}
   {:doc "The URL of an image accompanying or representing a page.",
    :term :site.fabricate.page/image,
    :type [:fn uri?]}
   {:doc "The Open Graph Protocol type of a page.",
    :term :me.ogp/type,
    :type :string}
   {:doc "The datetime (ISO 8601-compatible) a page was first published.",
    :term :site.fabricate.page/published-time,
    :type :time/zoned-date-time}
   {:term :site.fabricate.page/publish-dir,
    :doc "The directory where Fabricate pages should be published.",
    :type [:fn fs/exists?]}
   {:doc "The datetime (ISO 8601-compatible) a source was first created.",
    :term :site.fabricate.source/created,
    :type :time/zoned-date-time}
   {:doc
      "The datetime (ISO 8601-compatible) a source was most recently updated.",
    :term :site.fabricate.source/modified,
    :type :time/zoned-date-time}
   {:doc "The datetime (ISO 8601-compatible) a page was most recently updated.",
    :term :site.fabricate.page/modified-time,
    :type :time/zoned-date-time}
   {:doc
      "Tags and labels describing the content of a page. May be strings, Clojure keywords, or Clojure symbols.",
    :term :site.fabricate.page/tags,
    :type [:* [:or :string :keyword :symbol]]}
   {:doc
      "The unique identifier for a document. May be a string, UUID, symbol, or Clojure namespace.",
    :term :site.fabricate.entry/id,
    :type [:or :string [:fn uuid?] :symbol :namespace]}
   {:doc "The Clojure namespace of an entry.",
    :term :site.fabricate.entry/namespace,
    :type :namespace}])

;; register schema components
(doseq [{:keys [term doc], :as d} definitions]
  (when-not (= :site.fabricate.api/entry term)
    (s/register! term (mu/update-properties (:type d) assoc :doc doc))))

(def entry-schema
  "Malli schema describing entries."
  (mu/required-keys
    (mu/optional-keys
      (m/schema [:map :site.fabricate.entry/source
                 :site.fabricate.source/location :site.fabricate.page/output
                 :site.fabricate.document/data :site.fabricate.document/format
                 :site.fabricate.source/format :site.fabricate.page/format
                 :site.fabricate.page/uri :site.fabricate.page/title
                 :site.fabricate.page/permalink :site.fabricate.page/description
                 :site.fabricate.page/author :site.fabricate.page/language
                 :site.fabricate.page/locale :site.fabricate.page/image
                 :me.ogp/type :site.fabricate.page/published-time
                 :site.fabricate.page/publish-dir :site.fabricate.source/created
                 :site.fabricate.source/modified
                 :site.fabricate.page/modified-time :site.fabricate.page/tags
                 :site.fabricate.entry/id :site.fabricate.entry/namespace]))
    ;; entries ultimately have to come from somewhere.
    [:site.fabricate.api/source :site.fabricate.source/location
     :site.fabricate.source/format]))

(defmulti collect
  "Generate the input entries from a source."
  (fn [src _settings] src))

(defmethod collect "pages/**.fab"
  [src settings]
  (mapv (fn path->entry [p]
          {:site.fabricate.source/format :site.fabricate.read/v0,
           :site.fabricate.document/format :hiccup,
           :site.fabricate.source/location (fs/file p),
           :site.fabricate.api/source src,
           :site.fabricate.source/created (time/file-created p),
           :site.fabricate.source/modified (time/file-modified p),
           :site.fabricate.page/outputs
             [{:site.fabricate.page/format :html,
               :site.fabricate.page/location
                 (fs/file (:site.fabricate.page/publish-dir settings))}]})
    (fs/glob (System/getProperty "user.dir") src)))


;; example of single-file handling; conflict resolution can be handled
;; separately if there's overlap.

(defmethod collect "README.md.fab"
  [src settings]
  [{:site.fabricate.source/location (fs/file src),
    :site.fabricate.api/source src,
    :site.fabricate.source/created (time/file-created src),
    :site.fabricate.source/modified (time/file-modified src),
    :site.fabricate.page/title "Fabricate: README",
    :site.fabricate.source/format :site.fabricate.markdown/v0,
    :site.fabricate.document/format :markdown,
    :site.fabricate.page/outputs
      [{:site.fabricate.page/format :markdown,
        :site.fabricate.page/location
          (fs/file (str (:site.fabricate.page/publish-dir settings)
                        "/README.md"))}]}])



(defn collect-entries
  "Get the entries from each source location defined by the dispatch values of `collect`."
  [{:keys [site.fabricate.page/publish-dir], :as settings}]
  (vec (for [[collect-pattern _] (.getMethodTable collect)
             entry-data (collect collect-pattern settings)
             output (:site.fabricate.page/outputs entry-data)]
         (-> entry-data
             (dissoc :site.fabricate.page/outputs)
             (merge output)
             #_add-page-location))))

(defn plan
  "Generate the list of entries."
  [settings]
  (collect-entries settings))

;; not enforcing a spec on a multimethod seems like the best way of keeping
;; it open for extension, and keeps the API simpler.
(defmulti assemble
  "Generate structured (EDN) document content for an entry from a source format. Takes an entry and returns a document (entry)."
  {:term/definition
     {:source (URI. "https://www.merriam-webster.com/dictionary/assemble"),
      :definition "to fit together the parts of"}}
  (fn [entry] [(:site.fabricate.source/format entry)
               (:site.fabricate.document/format entry)]))

(defn fabricate-v0->hiccup
  "Generate a Hiccup representation of the page by evaluating the parsed Fabricate template of the page contents."
  [entry]
  (let [parsed-page (read/parse (slurp (:site.fabricate.source/location entry)))
        evaluated-page (read/eval-all parsed-page)
        page-metadata (page/lift-metadata evaluated-page
                                          (last (read/get-metadata
                                                  parsed-page)))
        hiccup-page [:html (page/doc-header page-metadata)
                     [:body
                      [:main
                       (apply conj
                         [:article {:lang "en-us"}]
                         (page/parse-paragraphs evaluated-page))]
                      [:footer [:div [:a {:href "/"} "Home"]]]]]]
    (assoc entry
      :site.fabricate.document/data hiccup-page
      :site.fabricate.page/title (:title page-metadata))))

(defmethod assemble [:site.fabricate.read/v0 :hiccup]
  [entry]
  (fabricate-v0->hiccup entry))

(defmethod assemble [:site.fabricate.markdown/v0 :markdown]
  [entry]
  (assoc entry
    :site.fabricate.document/data (slurp (:site.fabricate.source/location
                                           entry))))

;; (def assemble-index nil)

;; (defmethod assemble "index.html" [entry] (assemble-index entry))

(defn- output-path
  [input-file output-location]
  (cond (fs/directory? output-location)
        (fs/file (str output-location "/" (fs/file-name input-file)))
        (instance? java.io.File output-location) output-location))

(defmulti produce!
  "Produce the content of a file from the results of the `assemble` operation and write it to disk. Takes an entry and returns an entry."
  {:term/definition
   {:source (URI. "https://www.merriam-webster.com/dictionary/produce"),
    :definition
    "to make available for public exhibition or dissemination; to cause to have existence or to happen; to give being, form, or shape to; to compose, create, or bring out by intellectual or physical effort; to bear, make, or yield something"}}
  (fn [entry] [(:site.fabricate.document/format entry)
               (:site.fabricate.page/format entry)]))

(defn- check-path
  "Create the parent paths of the given file if they don't exist."
  [f]
  (let [dirs (->> f
                  (iterate fs/parent)
                  (take-while some?)
                  (drop 1))]
    (doseq [d dirs]
      (when-not (and (fs/exists? d) (fs/directory? d)) (fs/create-dir d)))
    f))


(defn write-hiccup-html!
  "Generate HTML from Hiccup data and write it to the given file."
  [hiccup-page-data output-file]
  (spit output-file (hiccup.page/html5 hiccup-page-data)))

(defmethod produce! [:hiccup :html]
  [entry]
  (let [output-file (fs/file (str (output-path
                                   (:site.fabricate.source/location entry)
                                   (:site.fabricate.page/location entry))
                                  ".html"))]
    (write-hiccup-html! (:site.fabricate.document/data entry) output-file)
    (-> entry
        (assoc :site.fabricate.page/output output-file
               :site.fabricate.page/format :html))))

(defmethod produce! [:markdown :markdown]
  [entry]
  (let [output-file (fs/file (str (output-path
                                   (:site.fabricate.source/location entry)
                                   (:site.fabricate.page/location entry))
                                  ".md"))]
    (spit output-file (:site.fabricate.document/data entry))
    (assoc entry :site.fabricate.page/output output-file)))

(def settings (atom {:site.fabricate.page/publish-dir "./"}))

(defn doc->page
  [{:keys [site.fabricate.document/title site.fabricate.document/data
           site.fabricate.document/id],
    :as entry}]
  (assoc entry
         :site.fabricate.page/data data
         :site.fabricate.page/title title
         :site.fabricate.page/id id))

(defn combine
  [tasks
   {:keys [site.fabricate.api/entries site.fabricate.api/settings], :as site}]
  (let [sorted-tasks tasks]
    (reduce (fn [entries task] (task entries)) entries sorted-tasks)))

(defn publish!
  "Finalize the website after running the `produce!` operation on every page."
  [options]
  nil)

(defn build!
  "`plan`, `assemble` and `produce!` all of the entries, writing their output to disk."
  [options]
  nil)

(defn rebuild!
  "Idempotent version of `assemble` and `produce!`; called when a file change is detected."
  [entry]
  nil)
