<!DOCTYPE html>
<html lang="en"><head><title>Fabricate | Organizing computation with Finite Schema Machines</title><link href="https://raw.githubusercontent.com/jensimmons/cssremedy/master/css/remedy.css" rel="stylesheet"><link href="css/extras.css" rel="stylesheet"><meta content="Fabricate" name="title" property="og:title"><meta content="Using precise schemas to map from data states to functions in Clojure." name="description" property="og:description"><meta content="width=device-width, initial-scale=1.0" name="viewport"><meta content="en_US" name="locale"><meta content="fabricate.site" name="site-name"><meta content="Fabricate" name="site-title" property="og:site_name"><meta charset="utf-8"><meta content="IE=edge" http-equiv="X-UA-Compatible"><style>@import "https://fonts.googleapis.com/css2?family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=Inter:wght@900&display=swap";

body {
  background-color: #EEEDED;
}

article {
  max-width: 40em;
  font-size: 22px;
  line-height: 1.35em;
  font-family: 'Inria Sans', sans-serif;
  border-left-color: #dc4032;
  border-left-style: solid;
  border-left-width: 2em;
}

article section {
  padding-left: 1.4em;
}

article h1, article h2, article h3, article h4 {
  font-family: Inter;
}

article h1 {
  font-size: 2.5rem;
  line-height: 1.35em;
}

article h2 {
  font-size: 1.7rem;
}

article h3 {
  font-size: 1.5rem;
}

article h4 {
  font-size: 1.3rem;
}

article pre {
  white-space: pre-wrap;
  font-size: 0.95rem;
}</style></head><article><article lang="en"><section><p></p><header><h1>Organizing computation with Finite Schema Machines</h1><h4>An extensible method of laying out functions executed by a program.</h4></header><figure><blockquote><p> Computation is a major topic of computer science, and almost every object that computes is naturally viewed as a state machine. Yet computer scientists are so focused on the languages used to describe computation that they are largely unaware that those languages are all describing state machines.</p></blockquote><figcaption>Leslie Lamport, <cite><a href="https://lamport.azurewebsites.net/pubs/state-machine.pdf">Computation and State Machines</a></cite> [2008]</figcaption></figure><p>
When I was on my ùëõth refactor of a thread macro with multiple embedded if expressions, I realized I was trying to handle lots of special cases without really thinking about them. But in the back of my mind, I knew I was trying to dispatch my function calls on the basis of whether the data I was passing through my function matched some predicate or other - another way of saying that the data was in a particular <em>state.</em></p><p>After some sketches revealed that my understanding of the concepts was muddled and confused, I extensively googled "state machine" with some extra surrounding words, and it helped me discover that Leslie Lamport paper. The math is over my head, but the concept inspired me to figure out a better way of organizing what functions to call and when. A month and a half later, here it is.</p><h2>State, Action, Function, Data</h2><p>Before going through the code, it's worth going over the definitions outlined by Lamport early on in the paper.</p><blockquote><p>I begin by considering what a computation is. There are several ways to define <em>computation.</em> For now, I take the simplest: a computation is a sequence of steps, which I call a <em>behavior.</em> There are three common choices for what a step is, leading to three different kinds of behavior:</p><dl><dt>Action Behavior</dt><dd>A step is an <em>action,</em> which is just an element of some set of actions. An action behavior is a sequence of actions</dd><dt>State Behavior</dt><dd>A step is a pair„Äàs,t„Äâof states, where a state is an element of some set of states.  A state behavior is a sequence s1 ‚Üí s2 ‚Üí s3 ‚Üí ¬∑¬∑¬∑ of states. The step„Äàsi,si+1„Äârepresents a transition from state si to state si+1.</dd><dt>State-Action Behavior</dt><dd>A step is a triple„Äàs,Œ±,t„Äâ, where s and t are states and Œ± is an action. A state-action behavior is a sequence s1Œ±1 ‚Üí s2Œ±2 ‚Üí s3Œ±3 ‚Üí ¬∑¬∑¬∑. The step„Äàsi, Œ±i,si+1„Äârepresents a transition from state si to state si+1 that is performed by action Œ±i.</dd></dl></blockquote><p>This terminology clarified the shaky concept in my head and in my messy sketches. I was attempting to define a state-action behavior: I wanted to call a function (action) on the basis of some property of the data I was currently working with (state). That function would change the properties of that data - in other words, advance it to a new state.</p><p>How should those states be defined? Fabricate already <a href="https://github.com/fabricate-site/fabricate/blob/main/src/site/fabricate/prototype/html.clj">extensively</a> uses the <code><a href="https://github.com/metosin/malli">malli</a></code> schema library, so that was a natural choice. Its expressivity makes it easy to define states and incrementally refine them to match the data being processed by a program. It also meant that I would have to write my own implementation of a finite state machine, as the existing libraries in the Clojure ecosystem don't really work with Malli. The closest library to this concept that I currently know of is <code><a href="https://github.com/agentbellnorm/dativity">Dativity</a></code>, which describes itself as a "stateless process engine." Fabricate's implementation, relying as it does on Malli, is different than Dativity's; it was a conceptual rather than implementational reference point.</p><h2>A simple implementation</h2><p>Let's take a tour through Fabricate's <code>fsm</code> namespace. The implementation is extremely simple right now, consisting of two functions:</p><pre><code class="language-clojure">(defn advance
  "Takes a value, matches it against the schema keys defined in the
   input state-action map, and calls the appropriate function to advance
   the value to the next state."
  {:malli/schema [:=> [:cat state-action-map :any] :any]}
  [fsm-map value]
  (let [union-schema (schema/unify (keys fsm-map))
        parsed (m/parse union-schema value)]
    (if (= :malli.core/invalid parsed)
      (do
        (println "unmatched value"
                 (me/humanize (m/explain union-schema val)))
        value)
      (let [matched-schema (-> union-schema
                               (nth (inc (first parsed)))
                               last)
            op (get fsm-map matched-schema)]
        (do
          (println "advancing fsm:" (get (m/properties matched-schema)
                                         :fsm/description))
          (op value))))))</code></pre><pre><code class="language-clojure">(defn complete [fsm-map value]
  (let [fsm-states (iterate (partial advance fsm-map) value)]
    (reduce (fn [current-state next-state]
              (if (= current-state next-state)
                (reduced current-state)
                next-state))
            fsm-states)))</code></pre><p>What do these do? They take a given piece of arbitrary Clojure data, and move it through a succession of states. This sequence is defined by a map mapping from  <code>malli</code> schemas to functions. Malli schemas are just data, so they are easy to use as map keys. If a piece of data matches one of the states in the keys, it is transformed by calling the corresponding function. If it doesn't, it is returned as-is.</p><p>Termination is defined as the same successive value getting returned twice, which is a fairly naive way of representing the fact that there's no longer an action to take. While simple, this aspect mirrors one part of the much more formal and rigorous semantics that Lamport describes in that "that there is no fundamental difference between termination and deadlock."</p><p>In Lamport's schema, state t in„Äàs,Œ±,t„Äâis derived from the output signature of the function, so it's implicit rather than explicit in the map representation.</p><p>There's nothing more to it than that. The challenge lies in precisely describing the succession of states required by the program.</p><h2>Fabricate's use of Finite Schema Machines</h2><p>The usage pattern followed by Fabricate is to successively add items to a closed map, such that the state advances when the computation producing that map entry is complete. Starting from a file path, it moves through a read step, a parse step, an evaluation step, and then a render step, after which it writes the file. Because this final function is run only for its side effects, it returns the same value as its input, thus terminating the computation in <code>fsm/complete</code>. This map-accumulation strategy is simple enough to test the implementation while still being extensible enough to dispatch on special cases.</p><p>One of the motivating concerns for this implementation was the ability to support multiple output types. Fabricate's <a href="https://github.com/fabricate-site/fabricate/blob/main/README.md">README</a> is a markdown file that is still generated by Fabricate, even though Fabricate doesn't include any Markdown parsers in its default dependencies; the library doesn't know anything about markdown, but it can still target it as an output format.</p><pre><code class="language-clojure"></code>(def
 markdown-state
 (mu/closed-schema
  (mu/merge
   evaluated-state
   [:map
    {:closed true,
     :fsm/description
     &quot;Fabricate markdown input evaluated as markdown string&quot;}
    [:file-extension [:enum &quot;md&quot; &quot;markdown&quot;]]])))
</pre><p>In the read step, data about the input file is appended to the map holding a page's state. This data allows us to dispatch functions on that map entry, running a function (after the evaluation step) that basically just renders the page as a markdown string for any pages that need to have Markdown as an <em>output</em>  format. This allows for special cases in the rendering pipeline to be handled merely by progressively refining the schema to pick out the parts of data that identify them, and writing functions that are compatible with the remaining states.</p><p>Similar logic could be used to dispatch on the input filetype. Fabricate doesn't use any markup, but Finite Schema Machines give any users who desire to use Markdown an extensible method for adding it (or asciidoc) to their own rendering pipelines.</p><p>Other state machine implementations are possible; one could update an entry in place in the same map, as long as the possible values for that entry were appropriately constrained. Other applications might not need to hold to as many pieces of intermediate information, and so could choose a different representation of the sequence of states.</p><h2>Limitations</h2><p>This implementation, such as it currently is, will make no attempt to prevent users from doing silly things like an infinite succession of states:</p><pre><code class="language-clojure">(fsm/complete {[:enum :A] (fn [_] :B), [:enum :B] (fn [_] :A)})</code></pre><p>Or from making a succession of states that only terminates when you reach an integer overflow:</p><pre><code class="language-clojure">(fsm/complete {:int inc} 1)</code></pre><p>It will also advance on the first match, so you have to think carefully about making your states mutually exclusive. Luckily, the fact that map keys have to be distinct in Clojure already forces you to do that for obviously overlapping inputs, but there are many more subtle cases, especially when you're working with maps that may have overlapping keys:</p><pre><code class="language-clojure">(fsm/advance {[:map {:closed true} [:a :int]] (fn [m] (update m :a inc)), [:map {:closed false} [:a :int]] (fn [m] (update m :a dec))})</code></pre><p>The value <code>{:a 1}</code> will just match against the first entry, even if that's not what you want. Map keys are unordered, so the best way to control this is to make the schemas as specific as possible. Fabricate deals with this by using closed maps and adding new keys to them as data advances through the states.</p><p>I have some design concepts for how the really obvious problems could be anticipated through a validation mechanism for the map defining the FSM, but that is a topic for a future expansion of this post.</p><h3>Why Not Just Use <code>cond/cond-></code> or Predicate Functions Mapped to Transforming Functions?</h3><p>That certainly is a way to achieve a similarly lightweight implementation of a lot of this concept. I prefer the schema-based approach because it then becomes possible to unify the schema and identify matching schemas with <code>malli.core/parse</code>,  which makes certain types of function dispatch much easier! Malli is also just a really great library, one that I think embodies the idea of declarative programming at its best.</p><h2>Not Quite Fully Abstract - But Clearer</h2><p>That said, gushing about how easy Malli and Clojure have made implementing this concept means I must admit that I'm not really following Lamport's main advice in that paper; I'm still fussing about with language details instead of using the formalism of pure mathematics (or TLA+) to achieve true rigor. But I didn't turn to Lamport's paper because I was interested in proving my static website generator correct; I think he might agree that personal experiments in generating static HTML are not a sufficiently complex and high-stakes problem to even warrant the use of proofs. I turned to the paper because I was struggling to think of a way to match states with functions. Thanks to the definitions provided in the second section of the paper, I eventually identified a simple and expressive way of doing so.</p><p>Malli isn't set theory, but it is simple and expressive enough that I am not as bogged down in implementation details, and I at least have become a bit more clear-eyed that I'm working with finite-state machines. Using it has forced me to think harder about just how I'm defining the data states I care about instead of just creating a true/false predicate that falls over on data of a slightly different shape than what it expects. It has forced me to think about how errors and exceptions fit into the state space of a program executing a series of functions on different sources of data. Lamport said the way to get better programs is to teach programmers to think better. For my part, I think implementing and using finite schema machines has done exactly that.
</p></section></article></article><footer><div><a href="/">Home</a></div></footer></html>